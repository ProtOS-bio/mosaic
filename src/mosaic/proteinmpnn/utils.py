from colabdesign.mpnn import mk_mpnn_model

def mpnn_gen_sequence(trajectory_st, num_seqs, model_name="v_48_020", weights="soluble", backbone_noise=0, binder_chain='A', target_chain='B', trajectory_interface_residues=None, omit_AAs="C", temperature=0.1):
    # clear GPU memory
    assert 'A' in binder_chain
    trajectory_pdb = "/tmp/trajectory.pdb"
    trajectory_st.write_pdb(trajectory_pdb)
    # initialise MPNN model
    mpnn_model = mk_mpnn_model(backbone_noise=backbone_noise, model_name=model_name, weights=weights)

    # check whether keep the interface generated by the trajectory or whether to redesign with MPNN
    design_chains = ','.join(sorted(binder_chain.split(',') + target_chain.split(',')))

    if trajectory_interface_residues is not None:
        fixed_positions = target_chain + ',' + trajectory_interface_residues
        fixed_positions = fixed_positions.rstrip(",")
        print("Fixing interface residues: "+trajectory_interface_residues)
    else:
        fixed_positions = target_chain

    # prepare inputs for MPNN
    mpnn_model.prep_inputs(pdb_filename=trajectory_pdb, chain=design_chains, fix_pos=fixed_positions, rm_aa=omit_AAs)

    # sample MPNN sequences in parallel
    mpnn_sequences = mpnn_model.sample(temperature=temperature, num=1, batch=num_seqs)

    return mpnn_sequences

# Assuming binder first
def get_binder_seqs(mpnn_full_sequences, binder_length):
    binder_seqs = [mpnn_full_sequence[:binder_length] for mpnn_full_sequence in mpnn_full_sequences['seq']]
    scores = mpnn_full_sequences['score']
    return binder_seqs, scores